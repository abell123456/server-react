'use strict';

const EventEmitter = require('events');
const once = require('once');
const ready = require('get-ready');
const extend = require('extend');
const uuid = require('uuid');
const debug = require('debug')('ready-callback');

const defaults = {
  timeout: 10000,
  isWeakDep: false,
};

/**
 * @class Ready
 */
class Ready extends EventEmitter {

  /**
   * @constructor
   * @param  {Object} opt
   *   - {Number} timeout - emit `ready_timeout` when it doesn't finish but reach the timeout, default: 10000ms
   *   - {Boolean} isWeakDep - whether it's a weak dependency, default: false
   */
  constructor(opt) {
    super();
    this.opt = opt || {};
    this.isError = false;
    this.cache = new Map();
    ready.mixin(this);
    setImmediate(function () {
      // fire callback directly when no registered ready callback
      if (this.cache.size === 0) {
        debug('Fire callback directly');
        this.ready(true);
      }
    }.bind(this));
  }

  /**
   * Mix `ready` and `readyCallback` to `obj`
   * @method Ready#mixin
   * @param  {Object} obj - The mixed object
   * @return {Ready} this
   */
  mixin(obj) {
    // only mixin once
    if (!obj || this.obj) return null;
    obj.ready = this.ready.bind(this);
    obj.readyCallback = this.readyCallback.bind(this);
    if (obj.emit) {
      this.on('ready_timeout', obj.emit.bind(obj, 'ready_timeout'));
      this.on('ready_stat', obj.emit.bind(obj, 'ready_stat'));
      this.on('error', obj.emit.bind(obj, 'error'));
    }
    this.obj = obj;
    return this;
  }

  /**
   * Create a callback, ready won't be fired until all the callbacks are triggered.
   * @method Ready#readyCallback
   * @param  {String} name -
   * @param  {Object} opt - the options that will override global
   * @return {Function} - a callback
   */
  readyCallback(name, opt) {
    const id = uuid.v1();
    opt = extend({}, defaults, this.opt, opt);
    opt.name = name || id;
    const timer = setTimeout(this.emit.bind(this, 'ready_timeout', opt.name), opt.timeout);
    const cb = once(function(err) {
      clearTimeout(timer);
      // won't continue to fire after it's error
      if (this.isError === true) return;
      // fire callback after all register
      setImmediate(this.readyDone.bind(this, id, opt, err));
    }.bind(this));
    debug('[%s] Register task id `%s` with %j', id, opt.name, opt);
    cb.id = opt.name;
    this.cache.set(id, cb);
    return cb;
  }

  /**
   * resolve ths callback when readyCallback be called
   * @method Ready#readyDone
   * @private
   * @param  {String} id - unique id generated by readyCallback
   * @param  {Object} opt - the options that will override global
   * @param  {Error} err - err passed by ready callback
   * @return {Ready} this
   */
  readyDone(id, opt, err) {
    if (err && !opt.isWeakDep) {
      this.isError = true;
      debug('[%s] Throw error task id `%s`, error %s', id, opt.name, err);
      return this.emit('error', err);
    }

    debug('[%s] End task id `%s`, error %s', id, opt.name, err);
    this.cache.delete(id);

    this.emit('ready_stat', {
      id: opt.name,
      remain: getRemain(this.cache),
    });

    if (this.cache.size === 0) {
      debug('[%s] Fire callback async', id);
      this.ready(true);
    }
    return this;
  }

}

module.exports = Ready;

function getRemain(map) {
  const names = [];
  for (const cb of map.values()) {
    names.push(cb.id);
  }
  return names;
}
